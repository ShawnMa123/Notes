# 1 数组

## 1.1.1 读取

1. 数组包含的四种基本操作：读取、查找、插入、删除
2. 操作速度是按照步数进行计算的
3. 读取的一些特点

![1%20%E6%95%B0%E7%BB%84%20dec645f064804c9caa3841c0a37b3b29/Untitled.png](1%20%E6%95%B0%E7%BB%84%20dec645f064804c9caa3841c0a37b3b29/Untitled.png)

这些特点是读取操作的前提 一个读取的例子

![1%20%E6%95%B0%E7%BB%84%20dec645f064804c9caa3841c0a37b3b29/Untitled%201.png](1%20%E6%95%B0%E7%BB%84%20dec645f064804c9caa3841c0a37b3b29/Untitled%201.png)

![1%20%E6%95%B0%E7%BB%84%20dec645f064804c9caa3841c0a37b3b29/Untitled%202.png](1%20%E6%95%B0%E7%BB%84%20dec645f064804c9caa3841c0a37b3b29/Untitled%202.png)

读取只需要用一步就可以了

# 1.1.2 查找

1. 这种逐个格子去检查的做法，就是最基本的查找方法——**线性查找**。
2. 线性查找需每个都检查一遍

    ![1%20%E6%95%B0%E7%BB%84%20dec645f064804c9caa3841c0a37b3b29/Untitled%203.png](1%20%E6%95%B0%E7%BB%84%20dec645f064804c9caa3841c0a37b3b29/Untitled%203.png)

3. 一个 N 格的数组，其线性查找的最多步数是 N（N 可以是任何自然数）
4. 无论是多长的数组，查找都比读取要慢，因为读取永远都只需要一步，而查找却可能需要多步

# 1.1.3 插入

1. 在数组中插入新元素的速度取决于插入的**位置。**   比如在末尾插入，只需要一步。因为计算机知道数组开头的内存地址，一共包含多少元素。
2. 一个数组插入的例子：把figs插入到索引2 

    ![1%20%E6%95%B0%E7%BB%84%20dec645f064804c9caa3841c0a37b3b29/Untitled%204.png](1%20%E6%95%B0%E7%BB%84%20dec645f064804c9caa3841c0a37b3b29/Untitled%204.png)

3. 插入在数组开头花费的步数最多（最低效），需要把所有的元素向右移动。
4. 数组，含有N个元素，插入数据最坏的情况需要N+1步。（插入在数组开头）

# 1.1.4 删除

1. 删除：在删掉数据后，要把数组向左移，填补空格
2. 一个删除的例子

    ![1%20%E6%95%B0%E7%BB%84%20dec645f064804c9caa3841c0a37b3b29/Untitled%205.png](1%20%E6%95%B0%E7%BB%84%20dec645f064804c9caa3841c0a37b3b29/Untitled%205.png)

3. 数组含有N个元素，删除最多需要N步（删除第一个）。

# 1.2 集合

1. 集合中不允许元素重复
2. 读取、查找、删除操作都和数组一致。 插入需要先查询是不是有重复值
3. 一个集合中插入操作的例子

    ![1%20%E6%95%B0%E7%BB%84%20dec645f064804c9caa3841c0a37b3b29/Untitled%206.png](1%20%E6%95%B0%E7%BB%84%20dec645f064804c9caa3841c0a37b3b29/Untitled%206.png)

4. 在N个元素的集合中进行插入，最好的情况需要N+1步（N步确认插入的值不在集合中，然后在最后插入）。最坏的情况是在开头插入，用N检查是否重复，N把后面的值右移，放在开头1步。最多需要2N＋１步。